package cache

import (
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
)

const CacheFile = "cache.json"

type HashMetadata struct {
	GopherVersion string    `json:"gopher_version"`
	GoVersion     string    `json:"golang_version"`
	Hashes        HashFiles `json:"hashes"`
}

func Valid(gopherfile string, directory string, goBin string) (bool, error) {
	var expectedHashMetadata HashMetadata
	expectedReader, err := os.Open(filepath.Join(directory, CacheFile))
	if err != nil {
		// Cache has not been run
		return true, nil
	}
	defer expectedReader.Close()

	decoder := json.NewDecoder(expectedReader)
	if err := decoder.Decode(&expectedHashMetadata); err != nil {
		// The cache is corrupted
		return true, nil
	}

	content, err := os.ReadFile(gopherfile)
	if err != nil {
		return false, fmt.Errorf("opening %s: %w", gopherfile, err)
	}

	hashes, err := CalculateFileHashes(content, directory)
	if err != nil {
		return false, err
	}

	existingHashMetadata := HashMetadata{
		Hashes:        hashes,
		GopherVersion: GopherVersion(),
		GoVersion:     GoVersion(goBin),
	}
	return existingHashMetadata == expectedHashMetadata, nil
}

func WriteCacheMetadata(gopherFile []byte, dir string, goBin string) error {
	hashes, err := CalculateFileHashes(gopherFile, dir)
	if err != nil {
		return fmt.Errorf("calculating hash: %w", err)
	}

	metadata := HashMetadata{
		Hashes:        hashes,
		GopherVersion: GopherVersion(),
		GoVersion:     GoVersion(goBin),
	}

	cacheWriter, err := os.OpenFile(filepath.Join(dir, CacheFile), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return fmt.Errorf("opening main.go: %w", err)
	}
	defer cacheWriter.Close()

	encoder := json.NewEncoder(cacheWriter)
	if err := encoder.Encode(metadata); err != nil {
		return fmt.Errorf("writing cache metadata to file: %w", err)
	}
	return nil
}

type HashFiles struct {
	GopherFile string `json:"gopherfile"`
	TargetFile string `json:"targets.go"`
	Main       string `json:"main.go"`
	GoMod      string `json:"go.mod"`
	GoSum      string `json:"go.sum"`
}

func CalculateFileHashes(gopherFileContents []byte, directory string) (HashFiles, error) {
	var hashes HashFiles
	var err error

	hashes.GopherFile = string(Hash(gopherFileContents))

	// NOTE: These are generated by us, so if they are missing
	//       We just leave them empty
	hashes.TargetFile, err = HashFile(filepath.Join(directory, "targets.go"))
	if err != nil {
		slog.Debug("could not open targets.go", "err", err)
	}

	hashes.Main, err = HashFile(filepath.Join(directory, "main.go"))
	if err != nil {
		slog.Debug("could not open main.go", "err", err)
	}

	// TODO: These are not made currently so uncomment when they are
	hashes.GoMod, err = HashFile(filepath.Join(directory, "go.mod"))
	if err != nil {
		slog.Debug("could not open go.mod", "err", err)
	}

	hashes.GoSum, err = HashFile(filepath.Join(directory, "go.sum"))
	if err != nil {
		slog.Debug("could not open go.sum", "err", err)
	}
	return hashes, nil
}
func HashFile(filepath string) (string, error) {
	content, err := os.ReadFile(filepath)
	if err != nil {
		return "", err
	}
	return Hash(content), nil
}

func GoVersion(goBin string) string {
	// Returns empty string if it could not determine the go version
	// TODO: Implement
	return "Unknown"
}

func GopherVersion() string {
	// TODO: Implement
	return "Initial file cache commit"
}

func Hash(content []byte) string {
	hash := sha256.New()
	hash.Write(content)
	return fmt.Sprintf("%x", hash.Sum(nil))
}
